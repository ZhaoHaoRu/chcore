# lab2

### 赵浩如 520021910352

## 思考题1

> 思考题 1：请思考多级页表相比单级页表带来的优势和劣势（如果有的话），并计算在 AArch64 页表中分别以 4KB 粒度和 2MB 粒度映射 0～4GB 地址范围所需的物理内存大小（或页表页数量）。

1. 优势：由于多级页表允许页表中出现空洞，若某级页表对应的某条目为空，那么该条目对应的下一级页表都无需存在，因此在应用程序的虚拟地址空间大部分都没有分配的情况下，多级页表可以有效压缩页表的大小
2. 劣势：

   * 由于需要在多级页表中进行查找，相比与单级页表速度有所下降
   * 如果应用程序的虚拟地址空间大多分配，多级页表会引起空间浪费的问题
3. `4KB`粒度： `4GB`的地址范围对应的页的数量是$4GB/4KB = 2^{32} / 2^{12} =  2^{20}$, 在每一级页表中，所对应的下一级 `PTE`的数量最多为$4KB/64bit = 2^{12} / 2 ^{3} = 2^9$, 所以所需要的 `L3`级页表的数量为$2^{20} / 2^9 = 2^{11}$, 需要的 `L2`级页表的数量为$2^{11} / 2^{9} = 2^2$, 需要的 `L1`和 `L0`级页表的数量为1，所以需要的页表总数为$2^{11} + 2^2 + 1 + 1 = 2054$, 所占用的物理内存大小为$8216KB$
4. `2MB`粒度：`4GB`的地址范围对应的页的数量为$4GB/4KB = 2^{32} / 2^{21} =  2^{11}$, 所以所需要的 `L2`级页表的数量为$2^{11} / 2^9 = 2^{2}$, 需要的 `L1`和 `L0`级页表的数量为1，所以需要的页表总数为$2^{2} + 1 + 1 = 6$, 所占用的物理内存大小为$24KB$

## 练习题2

> 练习题 2：请在 `init_boot_pt` 函数的 `LAB 2 TODO 1` 处配置内核高地址页表（`boot_ttbr1_l0`、`boot_ttbr1_l1` 和 `boot_ttbr1_l2`），以 2MB 粒度映射。

1. 参照 `ttbr0` 的页表设置可以很方便的完成，只需将地址映射到高地址即可

   ```C
   vaddr = KERNEL_VADDR + PHYSMEM_START
   ```

   具体实现详见 `mmu.c`

## 思考题3

> 思考题 3：请思考在 `init_boot_pt` 函数中为什么还要为低地址配置页表，并尝试验证自己的解释。

在 `el1_mmu_activate`最开始的部分，尚未使用页表，使用的仍是低地址空间，在开启MMU之后，如果没有配置低地址空间的页表，程序无法正常运行。

验证：将配置低地址页表的代码注释掉以后，在 `Enable el1 MMU`以后无法跳转到 `kernel main`中正确的地方运行

## 思考题4

> 思考题 4：请解释 `ttbr0_el1` 与 `ttbr0_el1` 是具体如何被配置的，给出代码位置，并思考页表基地址配置后为何需要ISB指令

代码在 `tool.S`的 `el1_mmu_activate`中

```C
adrp    x8, boot_ttbr0_l0
msr     ttbr0_el1, x8
adrp    x8, boot_ttbr1_l0
msr     ttbr1_el1, x8
isb
```

这里的指令的主要目的是将 `init_boot_pt()`中初始化的页表基地址写入页表基址寄存器

`ISB`指令的主要作用是指令同步隔离，清洗流水线，以保证所有它前面的指令都执行完毕之后，才执行它后面的指令。

这里是因为下面指令会立即修改 `x8`的值，这里要保证前面设置页表基地址的操作都已经完成
